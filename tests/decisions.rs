// Relative imports of sub modules
use common::setup;
mod common;

macro_rules! assert_decision {
    ($ctx: ident, $flag_key: ident, $user_id: expr, $enabled: expr, $variation_key: expr) => {{
        // Create new user context
        let user_context = $ctx.client.create_user_context($user_id);

        // Make decision for user
        let decision = user_context.decide_with_options($flag_key, &$ctx.decide_options);

        // Assert the decision is consitent with given values
        assert_eq!(decision.enabled(), $enabled);
        assert_eq!(decision.variation_key(), $variation_key);
    }};
}

#[test]
fn qa_rollout_flag() {
    let ctx = setup();
    let flag_key = "qa_rollout";

    // Test against decision generated by the Python SDK
    assert_decision!(ctx, flag_key, "user0", false, "off");
    assert_decision!(ctx, flag_key, "user1", false, "off");
    assert_decision!(ctx, flag_key, "user2", false, "off");
    assert_decision!(ctx, flag_key, "user3", true, "on");
    assert_decision!(ctx, flag_key, "user4", true, "on");
    assert_decision!(ctx, flag_key, "user5", false, "off");
    assert_decision!(ctx, flag_key, "user6", true, "on");
    assert_decision!(ctx, flag_key, "user7", true, "on");
    assert_decision!(ctx, flag_key, "user8", false, "off");
    assert_decision!(ctx, flag_key, "user9", true, "on");
    assert_decision!(ctx, flag_key, "user10", true, "on");
    assert_decision!(ctx, flag_key, "user11", true, "on");
    assert_decision!(ctx, flag_key, "user12", false, "off");
    assert_decision!(ctx, flag_key, "user13", true, "on");
    assert_decision!(ctx, flag_key, "user14", false, "off");
    assert_decision!(ctx, flag_key, "user15", true, "on");
}

#[test]
fn buy_button_flag() {
    let ctx = setup();
    let flag_key = "buy_button";

    // Test against decision generated by the Python SDK
    assert_decision!(ctx, flag_key, "user0", true, "primary");
    assert_decision!(ctx, flag_key, "user1", true, "danger");
    assert_decision!(ctx, flag_key, "user2", true, "primary");
    assert_decision!(ctx, flag_key, "user3", true, "primary");
    assert_decision!(ctx, flag_key, "user4", true, "danger");
    assert_decision!(ctx, flag_key, "user5", true, "success");
    assert_decision!(ctx, flag_key, "user6", true, "success");
    assert_decision!(ctx, flag_key, "user7", true, "danger");
    assert_decision!(ctx, flag_key, "user8", true, "danger");
    assert_decision!(ctx, flag_key, "user9", true, "success");
    assert_decision!(ctx, flag_key, "user10", true, "success");
    assert_decision!(ctx, flag_key, "user11", true, "danger");
    assert_decision!(ctx, flag_key, "user12", true, "danger");
    assert_decision!(ctx, flag_key, "user13", true, "danger");
    assert_decision!(ctx, flag_key, "user14", true, "success");
    assert_decision!(ctx, flag_key, "user15", true, "danger");
    assert_decision!(ctx, flag_key, "user16", true, "primary");
    assert_decision!(ctx, flag_key, "user17", true, "warning");
    assert_decision!(ctx, flag_key, "user18", true, "danger");
    assert_decision!(ctx, flag_key, "user19", true, "success");
    assert_decision!(ctx, flag_key, "user20", true, "warning");
    assert_decision!(ctx, flag_key, "user21", true, "danger");
    assert_decision!(ctx, flag_key, "user22", true, "danger");
    assert_decision!(ctx, flag_key, "user23", true, "primary");
    assert_decision!(ctx, flag_key, "user24", true, "success");
    assert_decision!(ctx, flag_key, "user25", true, "success");
    assert_decision!(ctx, flag_key, "user26", true, "primary");
    assert_decision!(ctx, flag_key, "user27", true, "warning");
    assert_decision!(ctx, flag_key, "user28", true, "primary");
    assert_decision!(ctx, flag_key, "user29", true, "danger");
    assert_decision!(ctx, flag_key, "user30", true, "success");
    assert_decision!(ctx, flag_key, "user31", true, "primary");
}

#[test]
fn invalid_flag() {
    let ctx = setup();
    let flag_key = "this_flag_does_not_exist";

    // An invalid flag should always be disabled
    assert_decision!(ctx, flag_key, "user1", false, "off");
    assert_decision!(ctx, flag_key, "user2", false, "off");
    assert_decision!(ctx, flag_key, "user3", false, "off");
    assert_decision!(ctx, flag_key, "user4", false, "off");
}
